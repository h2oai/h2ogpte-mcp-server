from pathlib import Path
from setuptools import build_meta, setup, Distribution
from setuptools.build_meta import *  # type: ignore
from setuptools.command.build_py import build_py
from setuptools.command.build_ext import build_ext
from typing import Any, cast
from zipfile import ZipFile
from Cython.Build import cythonize

__all__ = ["build_wheel"]

ALLOWED_PYTHON_FILES = ("__init__.py", "__main__.py")


# This is a [PEP-517](https://peps.python.org/pep-0517/#build-wheel)-required
# build function. It will be invoked by the Python runtime in order to build
# the wheel file. The function must create the wheel file inside the
# [wheel_directory], and then return the base name of the file created.
#
# This implementation is a wrapper around [setuptools.build_meta.build_wheel],
# with the following augmentations:
# - instead of `run_setup()` (which executes "setup.py"), this function will
#   call [custom_setup] instead.
# - after building the wheel, it will call [audit_wheel], and also clean up
#   the generated C files.
#
def build_wheel(
    wheel_directory: str,
    config_settings: dict[str, Any] | None = None,
    metadata_directory: str | None = None,
) -> str:
    original_setup = build_meta.build_wheel.__self__.run_setup
    build_meta.build_wheel.__self__.run_setup = custom_setup
    wheel_file = build_meta.build_wheel(
        wheel_directory, config_settings, metadata_directory
    )
    build_meta.build_wheel.__self__.run_setup = original_setup
    audit_wheel(Path(wheel_directory) / wheel_file)
    remove_autogenerated_c_files()
    return wheel_file


# This function can have any code that one would normally put inside "setup.py".
#
def custom_setup(setup_script: str = "setup.py"):
    assert Distribution().get_command_class("build_py") == build_py
    assert Distribution().get_command_class("build_ext") == build_ext

    class CustomBuildPy(build_py):
        def find_package_modules(
            self, package: str, package_dir: str
        ) -> list[tuple[str, str, str]]:
            result = cast(
                list[tuple[str, str, str]],
                super().find_package_modules(package, package_dir),  # type: ignore
            )
            return [
                entry for entry in result if f"{entry[1]}.py" in ALLOWED_PYTHON_FILES
            ]

    class CustomBuildExt(build_ext):
        def get_source_files(self) -> list[str]:
            return []

    class CustomDistribution(Distribution):
        def __init__(self, attrs: Any = None):
            super().__init__(attrs=attrs)
            self.cmdclass["build_py"] = CustomBuildPy
            self.cmdclass["build_ext"] = CustomBuildExt

    extensions = cythonize(
        find_cythonizable_sources(),
        compiler_directives={
            "always_allow_keywords": True,
            "language_level": 3,
        },
        nthreads=4,
    )
    for ext in extensions:
        ext.extra_compile_args.append("-Wno-unreachable-code")
        ext.extra_compile_args.append("-Wno-unreachable-code-fallthrough")

    setup(
        distclass=CustomDistribution,
        ext_modules=extensions,
    )


def find_cythonizable_sources() -> list[str]:
    """
    Returns the list of files that need to be cythonized. By default, we look
    for any python files inside the project's `src/` folder, excluding the
    files from [ALLOWED_PYTHON_FILES] list.
    """

    def recurse(path: Path) -> list[Path]:
        out: list[Path] = []
        if path.is_dir():
            for entry in path.iterdir():
                if str(entry).endswith(".egg-info"):
                    continue
                if entry.is_file() and entry.suffix == ".py":
                    if entry.name not in ALLOWED_PYTHON_FILES:
                        out.append(entry)
                if entry.is_dir():
                    out.extend(recurse(entry))
        return out

    return [str(p) for p in recurse(Path("src"))]


def audit_wheel(path: Path):
    """
    Checks that the wheel file at [path] doesn't contain any forbidden files.
    The following files are forbidden:
    - all python files except [ALLOWED_PYTHON_FILES];
    - all C/C++ source files.
    """
    if not (path.is_file() and path.suffix == ".whl"):
        raise RuntimeError(f"Cannot find wheel file {path}")
    with ZipFile(path, "r") as zipf:
        for name in zipf.namelist():
            pname = Path(name)
            if pname.name in ALLOWED_PYTHON_FILES:
                continue
            if pname.suffix in (".py", ".c", ".cc", ".cxx"):
                raise RuntimeError(f"Invalid file inside the wheel: {name}")


def remove_autogenerated_c_files():
    """
    Since `cythonize()` creates C files and leaves them in the source tree,
    this function is used to remove those files after the wheel is built.
    """
    files_to_remove = list(Path("src").glob("**/*.c"))
    for f in files_to_remove:
        f.unlink()
